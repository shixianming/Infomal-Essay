一.知识普及
1.CLI：公共语言基础结构
1）CIL：公共中间语言（Common Intermediate Language）
2）CLR：公共语言运行库--内存管理、异常处理、垃圾收集（GC）、反射服务、JIT即时编译器、类加载器、安全服务
3）CLS：公共语言规范
4）CTS：公共类型系统
5）基类库
6）元数据定义及语义

二.C#基础知识
1）Framework框架选择：4.7.2（选择与版本对应的）
2）类型：C#是一个现代的，通用的，面向对象的强数据类型语言
3）注意事项：a--名字要见名知意，多加注释
			b--单独行为抽象出一个方法
			c--标识符由大小写子母，下户线，@组成；不能以数字开头，@只能用在开头，不推荐作为常用字符
			d--命名约定用pascal（帕斯卡命名）给类名和方法命名，Camel（驼峰命名）给变量命名

三.C#
1.基本语法
1）输入：a--Read():获取一个字符，返回的是int类型，输入字符会返回它的unicode编码
        b--ReadLine():获取字符串，返回的是一个字符串，以回车键结束
		c--ReadKey():等待按键并读取
2）输出：a--Write():不换行输出
		b--WriteLine():换行输出
3）数据类型：a--整型:int占4个字节、long占8个字节
			b--浮点型
			c--字符型（默认值为0.0f/d）:char占两个字节
			d--布尔型（默认值为false）
注：数据类型分为值类型和引用类型，枚举属于值类型，sizeof是运算符，不是函数
4）栈：区别于计算机底层的栈，这里的栈是程序当前的执行环境，值类型一般存放于栈中（值类型只需要一段单独的内存）
5）堆：CLR自动GC在判断出程序的代码，会自动清除无主的堆对象，引用类型存放于堆中（引用类型需要两段内存，一段在堆里面存放数据，一段在栈里面存放引用）
2.流程控制和位运算符
1）&这些符号，既可以当位运算符也可以当逻辑运算符；&&只能当逻辑运算符
3.可空值类型
1）'?'可使基本数据类型赋值null，在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用
例如，数据库中的布尔型字段可以存储值true或false或者该字段也可以未定义。意思是这个数据类型是NullAble类型的
2）可空类型和非可空类型可以相互转换
3）可空类型赋值有三种方式：a--底层类型值
						b--可空类型值
						c--null
4.关键字
1）var关键字：并不是类型符号而是语法速记，只能用于本地变量，一旦推断出变量的类型,就是固定且不能更改的
2）ref关键字：从函数外部传到内部，使用ref时函数外必须初始化，在函数内对传入的参数进行操作
3）out关键字：从函数内部传到外部，使用out时函数内必须初始化，而函数外可以只声明
+：var（在编译时转化为对应的数据类型）、dynamic（在运行时转化为对应的数据类型，消耗更高）
5.数组
1）数组是对象：存储值为值类型时，数组为值类型数组；存储值为引用类型时，数组为引用类型
2）C#的动态数组是固定的：也就是在声明并初始化以后在编译期间是不能改变的，也就是没有增删改查等操作
3）概念：是保存一堆有顺序有大小的相同数据类型的集合

6.运算符
1）位运算符：--a.& 两边都为1才是1
			--b.| 两边只要有一个1就是1
			--c.^ 两边不同才为1
			--d.<< 二进制左移运算符，高位丢弃，低位补0，左移多少位相当于乘以2的几次方
			--e.>> 二进制右移运算符，					 右移多少位相当于除以2的几次方

三.类
1.类的基本组成
1）静态成员类型：字段、方法、属性、构造、事件
			   a--静态字段被类的所有实例所共享，所有实例都访问同一内存地址，用类名点运算符的方式来访问静态字段
			   b--静态函数成员不能访问实例成员，可访问静态成员
			   c--静态成员不依赖实例静态方法独立于任何实例对象对象，即使没有任何实例对象，也能直接访问
2）静态构造函数：只能有一个静态构造函数，不能有访问修饰符，不能访问实例成员，无法显示调用，总是隐式存在
注：静态构造函数用于初始化静态字段，当静态字段在声明时已经初始化，这时候再使用静态构造时，以静态构造初始化为标准
静态成员和方法生命周期是程序运行期间和全局性的，可能出于垃圾回收概念，只能初始化一次，所以当存在静态构造函数时
静态构造先执行，而静态成员只能初始化一次，所以以静态构造函数的初始化为准
3）静态类：静态类没有实例，一般用于工具类，只使用类的方法；静态类的内部都是静态的，没有索引器和析构，可以有静态构造
没有实例构造,也就是没有实例，也不能作为父类被继承，也不能继承其他类
4）密封类：没有继承，保证良好的封装性，可以继承于其他类
5）抽象类：不能实例，使用abstract关键字，由抽象成员和非抽象成员组成，对于抽象成员必须在其派生类中强制实现
6）常量：没有存储位置，只是在编译的时候被替换，使用const关键字定义
+:（const）静态常量和（readonly）动态常量，一个在编译时解析，一个在运行时进行解析；静态常量无内存消耗，动态常量有内存消耗
7）索引器：不可显示调用，可以被重载，get，set方法访问级别同属性，只能对单一方法做访问修饰限定，不用分配内存，用来访问多个类成员，不能静态化
2.继承
1）所有类都继承于Object类，在C#中单线继承，层次不限
2）this访问本类成员，base访问父类成员
3）virtual和override：父类中需要重写的方法使用virtual关键字，子类中重写父类的方法使用override关键字
4）构造函数和析构函数不会被继承
5）子类调用其构造函数的时候，如果没有进行特别的指令，都是调用父类的无参构造函数
3.接口
1）概念：对行为进行封装，以实现单继承时的多态效果，是引用类型，不能实例化，但是可以获取引用
2）方法：接口内的方法都是不实现的方法，实现接口时要实现接口的方法，类和结构体可以实现接口
3）声明：按照惯例，必须以I开头--a.接口不包含数据成员
						     b.只包含方法、属性、事件、索引
							 c.方法成员不允许实现
							 d.接口内放的是一堆方法的声明
标注：Basis04（几种类的区别于使用）      
4.多态
1）概念：多态是同一个行为具有多个不同的表现形式或形态能力；在面向对象编程中，往往表现为“一个接口，多个功能”
2）静态和动态：多态性是可以为静态或者动态的--a.在静态多态性中，函数的响应是在编译时发生的
										 b.在动态多态性中，函数的响应是在运行时发生的
3）静态绑定和动态绑定：面向对象的多态性是分为静态和动态的--a.静态绑定（早期绑定）：编译时函数和对象的连接机制，两种技术实现静态多态性
函数的重写；自认为：实现静态多态性就是使用virtual关键字在基类中声明要多态的方法，让子类通过override关键字重写该方法实现多态
													    b.动态绑定（晚期绑定）：在程序运行时发生函数响应，自认为通过abstract抽象方法
实现动态多态性，抽象方法在子类继承的时候强制实现
4）virtual和abstract：都是用来修饰父类的，通过覆盖父类的定义让子类重新定义--a.virtual在父类中修饰的方法必须有方法体，子类需要实现该
方法的多态时，需要通过override关键字重写此方法
																	   b.abstract在父类中修饰的放法没有方法体，子类在继承时
强制通过override关键字实现该方法，以达到多态的效果
总结：实现多态有两种方式一种是虚方法，子类需要实现多态时就需要重写此方法，不做强制要求，一种是抽象方法，子类在继承
时强制重写此方法，实现多态
5.委托
1）是一种用户自定义的类型，是引用类型，是一种方法的集合
2）为委托对象增加方法，这些方法必须与定义的委托类型有相同的签名和返回值
3）委托变量可以用new关键字也可以使用快捷语句进行赋值
4）可以通过-=和+=来进行删减或者添加委托方法
5）可以像方法一样调用委托也可以使用快捷语句
6）委托的本质是类，其作用和函数指针类似 
6.事件
1）使用event关键字
2）本质上是一个委托，只能在类内使用,在类外只能赋值，不能调用；事件实际上是委托的再一次封装
7.匿名方法 
1）lamda表达式
2）在类内使用时声明一个委托并使用匿名函数将其实例
8.扩展方法
1）封装一个静态类，然后封装静态方法作为扩展方法
2）改扩展方法形参列表使用this关键字加类的实例
注：使用扩展方法可以更好的进行封装解决战斗系统封装性问题
四.结构体
1）结构体和类的区别：结构体是值类型，类是引用类型
2）构造函数：如果要声明结构体构造函数，只能声明有参构造，并对结构体的所有字段进行初始化
3）析构函数：结构体有自己的处理内存的方式，不能显示声明析构函数
4）结构体不能继承结构体，但是能实现接口，结构体也没有静态

五.枚举
1.枚举使用enum关键字，内部只有一个成员：常量成员
2.枚举是值类型，且枚举包含自己的值，不能被继承或者传递继承

++API
1.数组
1）矩形数组--a.arr.GetLength()：获取每一行的长度
			b.Arrary.Sort()：对数组进行排序
			c.Arrary.Reverse()：对数组进行倒序
2）强制类型转换--a.i.ToString()：将i转换成string类型（Convert）
				b.str.ToCharArrary()：将字符串转成字符数组（string）				
2.动态链接库
1）创建.dll文件：在解决项目中点击属性，修改控制台为类库->选择框架->保存->生成->得到.dll文件->在新项目中引用添加.dll文件

C#知识点补充
1.如果在写字段的时候，默认省略了访问权限修饰符，那么字段的访问权限修饰符为private，在编译过程中，编译器会自动加上
2.类之前如果省略了访问权限修饰符，那么默认权限为internal权限（程序集访问）
3.如果一个类中没有写出任何构造函数，那么在编译过程中，编译器会自动给当前类加上一个公共的不带参数的构造函数
4.无论类中的字段是直接初始化还是在构造函数中进行初始化，在编译过程中都是在构造函数中进行初始化
5.属性的两个访问器在编译的过程中会转化成对应的两个函数（访问器的本质就是函数）
6.set访问器中的value实际上set访问器转化为对应的函数的形参名字
7.访问器如果没有特别声明访问权限，那么访问权限默认为public
8.访问器前面可以声明访问权限修饰符，这样可以让当前属性更具有灵活性
9.接口中的属性声明不是自动属性，只是get和set访问器的声明
10.自动属性不与类中的字段挂钩，自动属性在编译过程中，编译器会自动生成一个字段与当前属性联系起来
11.".h"和<.h>的区别
12.迭代器的特点：--a.无论当前容器内部结构是什么样的，我们使用迭代器都能把这个容器内的所有元素都遍历一遍
			    --b.必须把这个容器内的所有元素遍历一遍，不允许中途退出
				--c.在遍历的过程中，元素不允许修改，只能被拿来使用
13.两个值类型之间的“==”判断的是值是否相等；引用类型之间的“==”判断的是地址是否一致；特别的string的“==”是来判断值是否相等
14.大量字符串操作时使用StringBuilder--StringBuilder是可变长度的，其首先在内存中分配固定的长度，当进行频繁的插入和连接操作
时，超出了内存中分配的长度会自动进行扩充，从而有效的节约了内存空间和减少了生成对象的时间
15.string与stringBuilder的区别--a：string在声明之后在内存中的大小是不可修改的，而stringBuilder可以自由扩展大小(string分配在栈区，stringBuilder分配在堆区)
							   b：stringBuilder在指定分配大小之后，性能就会得到提升，在达到指定容量之前，它不会为自己重新分配空间，如果超过了指定大小，其内
							   存会倍增，也可以通过Capacity来设置其最大容量
